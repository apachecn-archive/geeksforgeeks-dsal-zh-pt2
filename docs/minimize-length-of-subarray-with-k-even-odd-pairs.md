# 用 K(偶数、奇数)对最小化子阵列长度

> 原文:[https://www . geeksforgeeks . org/最小化具有 k 个奇偶对的子阵列的长度/](https://www.geeksforgeeks.org/minimize-length-of-subarray-with-k-even-odd-pairs/)

给定一个由 **N** 正整数和一个整数 **K** 组成的[数组](https://www.geeksforgeeks.org/introduction-to-arrays/)**arr【】】**，任务是找到子阵列的**最小**长度，使得存在至少 K**对偶数和奇数元素，前提是偶数元素出现在**奇数元素之前**。如果没有这样的子阵列，则打印**-1”**。**

**示例:**

> **输入:** K = 2，A[] = {1，2，3，4，5}
> **输出** : 4
> **说明:**
> 子阵{2，3，4，5}长度为 4，最小。它至少有 K(= 2)对，如{2，3}、{2，5}和{4，5}。
> 
> **输入:** K = 3，A[] = {2，3，4，1，2，3}
> **输出:** 4
> **说明:**子阵{2，3，4，1}长度为 4，最小。它至少有 K(= 3)对，如{2，3}、{2，1}和{4，1}。

**天真方法:**解决给定问题的最简单方法是生成给定阵列的所有可能的[子阵列](https://www.geeksforgeeks.org/subarraysubstring-vs-subsequence-and-programs-to-generate-them/)，并找出每个子阵列中满足给定标准的对的数量。检查所有子阵列后，打印具有至少 K 对偶数和奇数元素的**子阵列的最小长度，使得偶数元素出现在奇数元素之前。**

***时间复杂度:**O(N<sup>4</sup>)*
***辅助空间:** O(1)*

**有效方法:**给定的问题可以通过使用[双指针技术](https://www.geeksforgeeks.org/two-pointers-technique/)来解决。考虑大小为 **N** 的阵列 **A[]** ,

*   考虑两个指针 **p1** 和 **p2、**将 p1 初始化为 **0** ，将 p2 初始化为 **-1** ，这两个指针将代表当前窗口大小。
*   假设有两个变量 **num_pairs** (存储有效对的数量)和 **final_ans** (存储至少有 **K** 个有效对的最小可能子阵列的长度，并用 **INT_MAX** 初始化)。
*   遵循以下步骤，直到 **p2** 超出范围，即直到 **p2 < N** :
*   **将** **p1** 固定在同一位置，并保持**增加** **p2** 并继续增加在增加 p2 的同时生成的新的有效对。继续这个过程，直到有效对的数量少于 **K.** 一旦 **num_pairs** 变成至少 **K** ，更新 **final_ans** 并停止。
*   现在，开始**增加 p1** 和**将 p2** 固定在同一位置(上一步后的位置)。在增加 p1 的同时，保持**减去**作为包含元素**A【p1】**的结果的有效对，然后增加 P1。该过程一直持续到有效对的计数大于或等于 **K** 。执行此过程时，随着 p1 和 p2 的变化，跟踪最小长度子阵列(fin_ans)。
*   返回**最终 _ans** 。

**计算{p1，p2}范围内有效对的数量:**

*   保持偶数和奇数元素数量的**累计**计数数组偶数[N]和奇数[N]，直到索引 I，A[0，i]
*   Now, whenever pointer p2 is increased, we add the number of **valid pairs** generated by including the element **A[p2]** to the **num_pairs.**There are two cases:

    **情况 1:** 当**A【p2】**为**偶数**时，那么通过将该元素考虑到现有的子阵列(A[p1，p2-1])中，则**不会有**有效对数量的任何增加。

    **情况 2:** 当 **A[p2]** 为**奇数**时，则通过将该元素考虑到现有子阵列(A[p1，p2-1])中，将生成那些有效对的数量，这些有效对的数量**等于{p1，p2-1}范围内的偶数数量**。由于该范围内的每个偶数都与这个新添加的奇数元素形成新的对，因此可以使用数组**evens【N】**直接计算。

*   Now, while **increasing** the pointer p1, subtract those number of **valid** **pairs** from **num_pairs** which were generated by the inclusion of the element **A[p1]**.

    有两种情况:

    **情况 1:** 当 **A[p1]** 为**奇数**时，则通过从现有子阵列(A[p1，p2])中移除该元素，有效对的数量不会有任何减少。

    **情况 2:** 当 **A[p1]** 为**偶数**时，则通过从现有子阵列(A[p1，p2])中移除该元素，应移除有效对的数量，该数量等于{p1+1，p2}范围内奇数的数量**。由于范围 A{p+1，p2}中的每一个奇数都将与偶数 A[p1]形成一对，这可以使用数组**赔率【N】**直接计算。**

**下面是上述方法的实现:**

## **C++**

```
#include <bits/stdc++.h>
using namespace std;

// Function to calculate the length of the
// smallest possible sub array with at least K
// valid pairs.
int CalculateMinimumSubarray(int A[], int N, int K)
{
    // Vector to store the cumulative count of the number
    // of even numbers and odd numbers.
    // For every i, evens[i] and odds[i] represents
    // the number of evens and odd elements
    // encountered till index 'i'
    vector<int> evens(N, 0), odds(N, 0);

    if (A[0] % 2 == 0)
        evens[0] = 1;
    else
        odds[0] = 1;

    // Calculating the cumulative even and
    // odd vectors
    for (int i = 1; i < N; i++) {
        evens[i] += evens[i - 1] + (A[i] % 2 == 0);
        odds[i] += odds[i - 1] + (A[i] % 2 == 1);
    }

    // Store the minimum length subarray with
    // atleast K valid pairs
    int final_ans = INT_MAX;

    // Initializing two pointers.
    int p1 = 0, p2 = -1;

    // Stores the number of valid pairs in
    // the range {p1, p2}
    int num_pairs = 0;

    // Incrementing p2
    while (p2 < N) {

        // Incrementing pointer p2 until there
        // are atleast K valid pairs
        // between the range {p1, p2}.
        while (p2 < N && num_pairs < K) {
            p2++;

            // If p2 >= N, stop.
            if (p2 >= N) {
                break;
            }

            // If A[p2] is an even number, then
            // the number of valid pairs won't
            // increase, so just continue.
            if (A[p2] % 2 == 0) {
                continue;
            }

            // If A[p2] is an odd number, then those many
            // number of valid pairs will be generated which
            // which are equal to the number of even numbers
            // within the range {p1, p2-1}. Since every even
            // number forms a new pair with this odd element.
            int no_evens;
            if (p1 == 0) {
                no_evens = evens[p2];
            }
            else {
                no_evens = evens[p2] - evens[p1 - 1];
            }

            // Increment the num_pairs variable with
            // the number of even numbers in the range
            // {p1, p2-1} as calculated above.
            num_pairs = num_pairs + no_evens;

            // Update final_ans
            if (num_pairs >= K) {
                final_ans = min(final_ans, p2 - p1 + 1);
            }
        }
        if (p2 >= N) {
            break;
        }

        // Increment the pointer p1 until
        // num_pairs >= K.
        while (num_pairs >= K && p1 < p2) {

            // Update final_ans
            if (num_pairs >= K) {
                final_ans = min(final_ans, p2 - p1 + 1);
            }

            // If A[p1] is an odd number, then removing that
            // element won't decrease the num_pairs.
            if (A[p1] % 2 != 0) {
                p1++;
                continue;
            }

            // If A[p1] is an even number, then we should
            // subtract those number of valid pairs from
            // num_pairs which is equal to the number of odd
            // numbers in the range {p1+1, p2}. Since every
            // odd number in the range {p1+1, p2} would have
            // formed a pair with the even number at A[p1]
            int no_odds;
            if (p1 == 0) {
                no_odds = odds[p2];
            }
            else {
                no_odds = odds[p2] - odds[p1 - 1];
            }
            // now we decrease the num_pairs with the value
            // calculated above, that is number of odd
            // numbers from A[p1+1, p2]
            num_pairs = num_pairs - no_odds;
            p1++;
        }
    }

    // If final_ans is updated atleast once,
    // then it means there is atleast one sub-array
    // of some size with atleast K valid pairs.
    // And however we have calculated the subarray
    // of minimum length.
    // So we return its length.
    if (final_ans != INT_MAX) {
        return final_ans;
    }

    // If the final_ans is never updated,
    // it means that there is no subarray
    // of any size with atleast K valid
    // pairs. So we return -1.
    return -1;
}

// Driver Code
int main()
{
    int N = 5;
    int K = 2;
    int A[5] = { 1, 2, 3, 4, 5 };

    cout << CalculateMinimumSubarray(A, N, K) << endl;
}
```

## **Java 语言(一种计算机语言，尤用于创建网站)**

```
import java.util.Arrays;

class GFG {

    // Function to calculate the length of the
    // smallest possible sub array with at least K
    // valid pairs.
    public static int CalculateMinimumSubarray(int A[], int N, int K) 
    {

        // Vector to store the cumulative count of the number
        // of even numbers and odd numbers.
        // For every i, evens[i] and odds[i] represents
        // the number of evens and odd elements
        // encountered till index 'i'
        int[] evens = new int[N];
        int[] odds = new int[N];
        Arrays.fill(evens, 0);
        Arrays.fill(odds, 0);

        if (A[0] % 2 == 0)
            evens[0] = 1;
        else
            odds[0] = 1;

        // Calculating the cumulative even and
        // odd vectors
        for (int i = 1; i < N; i++) {
            evens[i] += evens[i - 1] + ((A[i] % 2 == 0) ? 1 : 0);
            odds[i] += odds[i - 1] + ((A[i] % 2 == 1) ? 1 : 0);
        }

        // Store the minimum length subarray with
        // atleast K valid pairs
        int final_ans = Integer.MAX_VALUE;

        // Initializing two pointers.
        int p1 = 0, p2 = -1;

        // Stores the number of valid pairs in
        // the range {p1, p2}
        int num_pairs = 0;

        // Incrementing p2
        while (p2 < N) {

            // Incrementing pointer p2 until there
            // are atleast K valid pairs
            // between the range {p1, p2}.
            while (p2 < N && num_pairs < K) {
                p2++;

                // If p2 >= N, stop.
                if (p2 >= N) {
                    break;
                }

                // If A[p2] is an even number, then
                // the number of valid pairs won't
                // increase, so just continue.
                if (A[p2] % 2 == 0) {
                    continue;
                }

                // If A[p2] is an odd number, then those many
                // number of valid pairs will be generated which
                // which are equal to the number of even numbers
                // within the range {p1, p2-1}. Since every even
                // number forms a new pair with this odd element.
                int no_evens;
                if (p1 == 0) {
                    no_evens = evens[p2];
                } else {
                    no_evens = evens[p2] - evens[p1 - 1];
                }

                // Increment the num_pairs variable with
                // the number of even numbers in the range
                // {p1, p2-1} as calculated above.
                num_pairs = num_pairs + no_evens;

                // Update final_ans
                if (num_pairs >= K) {
                    final_ans = Math.min(final_ans, p2 - p1 + 1);
                }
            }
            if (p2 >= N) {
                break;
            }

            // Increment the pointer p1 until
            // num_pairs >= K.
            while (num_pairs >= K && p1 < p2) {

                // Update final_ans
                if (num_pairs >= K) {
                    final_ans = Integer.min(final_ans, p2 - p1 + 1);
                }

                // If A[p1] is an odd number, then removing that
                // element won't decrease the num_pairs.
                if (A[p1] % 2 != 0) {
                    p1++;
                    continue;
                }

                // If A[p1] is an even number, then we should
                // subtract those number of valid pairs from
                // num_pairs which is equal to the number of odd
                // numbers in the range {p1+1, p2}. Since every
                // odd number in the range {p1+1, p2} would have
                // formed a pair with the even number at A[p1]
                int no_odds;
                if (p1 == 0) {
                    no_odds = odds[p2];
                } else {
                    no_odds = odds[p2] - odds[p1 - 1];
                }

                // now we decrease the num_pairs with the value
                // calculated above, that is number of odd
                // numbers from A[p1+1, p2]
                num_pairs = num_pairs - no_odds;
                p1++;
            }
        }

        // If final_ans is updated atleast once,
        // then it means there is atleast one sub-array
        // of some size with atleast K valid pairs.
        // And however we have calculated the subarray
        // of minimum length.
        // So we return its length.
        if (final_ans != Integer.MAX_VALUE) {
            return final_ans;
        }

        // If the final_ans is never updated,
        // it means that there is no subarray
        // of any size with atleast K valid
        // pairs. So we return -1.
        return -1;
    }

    // Driver Code
    public static void main(String args[]) {
        int N = 5;
        int K = 2;
        int A[] = { 1, 2, 3, 4, 5 };

        System.out.println(CalculateMinimumSubarray(A, N, K));
    }
}

// This code is contributed by saurabh_jaiswal.
```

## **蟒蛇 3**

```
import sys

# Function to calculate the length of the
# smallest possible sub array with at least K
# valid pairs.
def CalculateMinimumSubarray(A, N, K):

    # Vector to store the cumulative count of the number
    # of even numbers and odd numbers.
    # For every i, evens[i] and odds[i] represents
    # the number of evens and odd elements
    # encountered till index 'i'
    evens = [0 for i in range(N)]
    odds = [0 for i in range(N)]

    if (A[0] % 2 == 0):
        evens[0] = 1
    else:
        odds[0] = 1

    # Calculating the cumulative even and
    # odd vectors
    for i in range(1,N,1):
        evens[i] += evens[i - 1] + (A[i] % 2 == 0)
        odds[i] += odds[i - 1] + (A[i] % 2 == 1)

    # Store the minimum length subarray with
    # atleast K valid pairs
    final_ans = sys.maxsize

    # Initializing two pointers.
    p1 = 0
    p2 = -1

    # Stores the number of valid pairs in
    # the range {p1, p2}
    num_pairs = 0

    # Incrementing p2
    while (p2 < N):

        # Incrementing pointer p2 until there
        # are atleast K valid pairs
        # between the range {p1, p2}.
        while (p2 < N and num_pairs < K):
            p2 += 1

            # If p2 >= N, stop.
            if (p2 >= N):
                break

            # If A[p2] is an even number, then
            # the number of valid pairs won't
            # increase, so just continue.
            if (A[p2] % 2 == 0):
                continue

            # If A[p2] is an odd number, then those many
            # number of valid pairs will be generated which
            # which are equal to the number of even numbers
            # within the range {p1, p2-1}. Since every even
            # number forms a new pair with this odd element.
            no_evens = 0
            if (p1 == 0):
                no_evens = evens[p2]
            else:
                no_evens = evens[p2] - evens[p1 - 1]

            # Increment the num_pairs variable with
            # the number of even numbers in the range
            # {p1, p2-1} as calculated above.
            num_pairs = num_pairs + no_evens

            # Update final_ans
            if (num_pairs >= K):
                final_ans = min(final_ans, p2 - p1 + 1)
        if (p2 >= N):
            break

        # Increment the pointer p1 until
        # num_pairs >= K.
        while (num_pairs >= K and p1 < p2):

            # Update final_ans
            if (num_pairs >= K):
                final_ans = min(final_ans, p2 - p1 + 1)

            # If A[p1] is an odd number, then removing that
            # element won't decrease the num_pairs.
            if (A[p1] % 2 != 0):
                p1 += 1
                continue

            # If A[p1] is an even number, then we should
            # subtract those number of valid pairs from
            # num_pairs which is equal to the number of odd
            # numbers in the range {p1+1, p2}. Since every
            # odd number in the range {p1+1, p2} would have
            # formed a pair with the even number at A[p1]
            no_odds = 0
            if (p1 == 0):
                no_odds = odds[p2]
            else:
                no_odds = odds[p2] - odds[p1 - 1]
            # now we decrease the num_pairs with the value
            # calculated above, that is number of odd
            # numbers from A[p1+1, p2]
            num_pairs = num_pairs - no_odds
            p1 += 1

    # If final_ans is updated atleast once,
    # then it means there is atleast one sub-array
    # of some size with atleast K valid pairs.
    # And however we have calculated the subarray
    # of minimum length.
    # So we return its length.
    if (final_ans != sys.maxsize):
        return final_ans

    # If the final_ans is never updated,
    # it means that there is no subarray
    # of any size with atleast K valid
    # pairs. So we return -1.
    return -1

# Driver Code
if __name__ == '__main__':
    N = 5
    K = 2
    A = [1, 2, 3, 4, 5]

    print(CalculateMinimumSubarray(A, N, K))

    # This code is contributed by SURENDRA_GANGWAR.
```

## **C#**

```
using System;

public class GFG{

      // Function to calculate the length of the
    // smallest possible sub array with at least K
    // valid pairs.
    public static int CalculateMinimumSubarray(int[] A, int N, int K) 
    {

        // Vector to store the cumulative count of the number
        // of even numbers and odd numbers.
        // For every i, evens[i] and odds[i] represents
        // the number of evens and odd elements
        // encountered till index 'i'
        int[] evens = new int[N];
        int[] odds = new int[N];
        Array.Fill(evens, 0);
        Array.Fill(odds, 0);

        if (A[0] % 2 == 0)
            evens[0] = 1;
        else
            odds[0] = 1;

        // Calculating the cumulative even and
        // odd vectors
        for (int i = 1; i < N; i++) {
            evens[i] += evens[i - 1] + ((A[i] % 2 == 0) ? 1 : 0);
            odds[i] += odds[i - 1] + ((A[i] % 2 == 1) ? 1 : 0);
        }

        // Store the minimum length subarray with
        // atleast K valid pairs
        int final_ans = Int32.MaxValue;

        // Initializing two pointers.
        int p1 = 0, p2 = -1;

        // Stores the number of valid pairs in
        // the range {p1, p2}
        int num_pairs = 0;

        // Incrementing p2
        while (p2 < N) {

            // Incrementing pointer p2 until there
            // are atleast K valid pairs
            // between the range {p1, p2}.
            while (p2 < N && num_pairs < K) {
                p2++;

                // If p2 >= N, stop.
                if (p2 >= N) {
                    break;
                }

                // If A[p2] is an even number, then
                // the number of valid pairs won't
                // increase, so just continue.
                if (A[p2] % 2 == 0) {
                    continue;
                }

                // If A[p2] is an odd number, then those many
                // number of valid pairs will be generated which
                // which are equal to the number of even numbers
                // within the range {p1, p2-1}. Since every even
                // number forms a new pair with this odd element.
                int no_evens;
                if (p1 == 0) {
                    no_evens = evens[p2];
                } else {
                    no_evens = evens[p2] - evens[p1 - 1];
                }

                // Increment the num_pairs variable with
                // the number of even numbers in the range
                // {p1, p2-1} as calculated above.
                num_pairs = num_pairs + no_evens;

                // Update final_ans
                if (num_pairs >= K) {
                    final_ans = Math.Min(final_ans, p2 - p1 + 1);
                }
            }
            if (p2 >= N) {
                break;
            }

            // Increment the pointer p1 until
            // num_pairs >= K.
            while (num_pairs >= K && p1 < p2) {

                // Update final_ans
                if (num_pairs >= K) {
                    final_ans = Math.Min(final_ans, p2 - p1 + 1);
                }

                // If A[p1] is an odd number, then removing that
                // element won't decrease the num_pairs.
                if (A[p1] % 2 != 0) {
                    p1++;
                    continue;
                }

                // If A[p1] is an even number, then we should
                // subtract those number of valid pairs from
                // num_pairs which is equal to the number of odd
                // numbers in the range {p1+1, p2}. Since every
                // odd number in the range {p1+1, p2} would have
                // formed a pair with the even number at A[p1]
                int no_odds;
                if (p1 == 0) {
                    no_odds = odds[p2];
                } else {
                    no_odds = odds[p2] - odds[p1 - 1];
                }

                // now we decrease the num_pairs with the value
                // calculated above, that is number of odd
                // numbers from A[p1+1, p2]
                num_pairs = num_pairs - no_odds;
                p1++;
            }
        }

        // If final_ans is updated atleast once,
        // then it means there is atleast one sub-array
        // of some size with atleast K valid pairs.
        // And however we have calculated the subarray
        // of minimum length.
        // So we return its length.
        if (final_ans != Int32.MaxValue) {
            return final_ans;
        }

        // If the final_ans is never updated,
        // it means that there is no subarray
        // of any size with atleast K valid
        // pairs. So we return -1.
        return -1;
    }

    // Driver Code
    static public void Main (){

        int N = 5;
        int K = 2;
        int[] A = { 1, 2, 3, 4, 5 };

        Console.WriteLine(CalculateMinimumSubarray(A, N, K));
    }
}

// This code is contributed by Dharanendra L V.
```

## **java 描述语言**

```
<script>
        // JavaScript Program to implement
        // the above approach

        // Function to calculate the length of the
        // smallest possible sub array with at least K
        // valid pairs.
        function CalculateMinimumSubarray(A, N, K) 
        {

            // Vector to store the cumulative count of the number
            // of even numbers and odd numbers.
            // For every i, evens[i] and odds[i] represents
            // the number of evens and odd elements
            // encountered till index 'i'
            let evens = new Array(N).fill(0);
            let odds = new Array(N).fill(0)

            if (A[0] % 2 == 0)
                evens[0] = 1;
            else
                odds[0] = 1;

            // Calculating the cumulative even and
            // odd vectors
            for (let i = 1; i < N; i++) {
                evens[i] += evens[i - 1] + (A[i] % 2 == 0);
                odds[i] += odds[i - 1] + (A[i] % 2 == 1);
            }

            // Store the minimum length subarray with
            // atleast K valid pairs
            let final_ans = Number.MAX_VALUE;

            // Initializing two pointers.
            let p1 = 0, p2 = -1;

            // Stores the number of valid pairs in
            // the range {p1, p2}
            let num_pairs = 0;

            // Incrementing p2
            while (p2 < N) {

                // Incrementing pointer p2 until there
                // are atleast K valid pairs
                // between the range {p1, p2}.
                while (p2 < N && num_pairs < K) {
                    p2++;

                    // If p2 >= N, stop.
                    if (p2 >= N) {
                        break;
                    }

                    // If A[p2] is an even number, then
                    // the number of valid pairs won't
                    // increase, so just continue.
                    if (A[p2] % 2 == 0) {
                        continue;
                    }

                    // If A[p2] is an odd number, then those many
                    // number of valid pairs will be generated which
                    // which are equal to the number of even numbers
                    // within the range {p1, p2-1}. Since every even
                    // number forms a new pair with this odd element.
                    let no_evens;
                    if (p1 == 0) {
                        no_evens = evens[p2];
                    }
                    else {
                        no_evens = evens[p2] - evens[p1 - 1];
                    }

                    // Increment the num_pairs variable with
                    // the number of even numbers in the range
                    // {p1, p2-1} as calculated above.
                    num_pairs = num_pairs + no_evens;

                    // Update final_ans
                    if (num_pairs >= K) {
                        final_ans = Math.min(final_ans, p2 - p1 + 1);
                    }
                }
                if (p2 >= N) {
                    break;
                }

                // Increment the pointer p1 until
                // num_pairs >= K.
                while (num_pairs >= K && p1 < p2) {

                    // Update final_ans
                    if (num_pairs >= K) {
                        final_ans = Math.min(final_ans, p2 - p1 + 1);
                    }

                    // If A[p1] is an odd number, then removing that
                    // element won't decrease the num_pairs.
                    if (A[p1] % 2 != 0) {
                        p1++;
                        continue;
                    }

                    // If A[p1] is an even number, then we should
                    // subtract those number of valid pairs from
                    // num_pairs which is equal to the number of odd
                    // numbers in the range {p1+1, p2}. Since every
                    // odd number in the range {p1+1, p2} would have
                    // formed a pair with the even number at A[p1]
                    let no_odds;
                    if (p1 == 0) {
                        no_odds = odds[p2];
                    }
                    else {
                        no_odds = odds[p2] - odds[p1 - 1];
                    }

                    // now we decrease the num_pairs with the value
                    // calculated above, that is number of odd
                    // numbers from A[p1+1, p2]
                    num_pairs = num_pairs - no_odds;
                    p1++;
                }
            }

            // If final_ans is updated atleast once,
            // then it means there is atleast one sub-array
            // of some size with atleast K valid pairs.
            // And however we have calculated the subarray
            // of minimum length.
            // So we return its length.
            if (final_ans != Number.MAX_VALUE) {
                return final_ans;
            }

            // If the final_ans is never updated,
            // it means that there is no subarray
            // of any size with atleast K valid
            // pairs. So we return -1.
            return -1;
        }

        // Driver Code
        let N = 5;
        let K = 2;
        let A = [1, 2, 3, 4, 5];

        document.write(CalculateMinimumSubarray(A, N, K));

     // This code is contributed by Potta Lokesh
    </script>
```

****Output**

```
4
```** 

*****时间复杂度*** : O(N)
***辅助空间*** : O(N)**