# 根据给定的条件最大化数组中子序列的和

> 原文:[https://www . geesforgeks . org/基于给定条件从数组中最大化子序列之和/](https://www.geeksforgeeks.org/maximize-the-sum-of-a-subsequence-from-an-array-based-on-given-conditions/)

给定一个由 **N** 个整数组成的数组**a【】**，任务是执行以下操作:

*   选择一个子序列，对于该子序列的每一个 **p <sup>个</sup>元素**，计算乘积**p * a【I】**。
*   计算 **p * a[i]** 的计算值之和。
*   应该选择子序列，使得它最大化期望的和。

**示例:**

> **输入:** N = 3，a[] = {-1，3，4}
> **输出:** 17
> **解释:**
> 子序列{-1，3，4}最大化和= 1(-1) + 2(3) + 3(4) = 17
> **输入:** N = 5，a[] = {-1，-9，0，5，-7}
> **输出:**

**天真方法:**解决问题最简单的方法是[从数组](https://www.geeksforgeeks.org/generating-all-possible-subsequences-using-recursion/)中生成所有可能的子序列，并计算每个子序列的和。最后求最大和。
***时间复杂度:**O(N<sup>3</sup>)*
***辅助空间:** O(N)*

**高效方法:**上述方法可以通过[动态规划](https://www.geeksforgeeks.org/dynamic-programming/)进行优化。按照以下步骤解决问题:

*   对于每个元素，都存在两种可能性，即该元素要么是子序列的一部分，要么不是。
*   初始化一个 **dp[][]** 矩阵，其中 **dp[i][j]** 存储最大值:
    *   选择**a【I】**作为子序列的 **j <sup>第</sup>元素**生成的和，即:

        > a【I】* j+最大值 um(j + 1，i + 1)

*   Sum generated by not selecting **a[i]** as the **j<sup>th</sup> element** of the subsequence, that is:

    > maximumsum，i + 1)

    因此，循环关系为:

    > dp[i][j] =最大值(a[i] * j +最大值(j + 1，i + 1)，最大值(j，i + 1))

*   通过考虑每个数组元素的上述条件，继续更新 dp[][]表，并打印整个数组中可能的最大和。

下面是上述方法的实现:

## C++

```
// C++ program to implement
// the above approach
#include <bits/stdc++.h>
using namespace std;
const int N = 6;

// Function to select the array elements to
// maximize the sum of the selected elements
int maximumSum(int a[], int count, 
               int index, int n, 
               int dp[N][N])
{
    // If the entire array
    // is solved
    if (index == n)
        return 0;

    // Memoized subproblem
    if (dp[index][count] != -1)
        return dp[index][count];

    // Calculate sum considering the
    // current element in the subsequence
    int take_element = a[index] * count + 
                         maximumSum(a, count + 1, 
                                  index + 1, n, dp);

    // Calculate sum without considering the
    // current element in the subsequence
    int dont_take = maximumSum(a, count, 
                               index + 1, n, dp);

    // Update the maximum of the above sums
    // in the dp[][] table
    return dp[index][count] = max(take_element, 
                                  dont_take);
}

// Driver Code
int main()
{
    int n = 5;
    int a[] = { -1, -9, 0, 5, -7 };

    // Initialize the dp array
    int dp[N][N];
    memset(dp, -1, sizeof(dp));

    cout << (maximumSum(a, 1, 0, n, dp));
}

// This code is contributed by Rajput-Ji
```

## Java 语言(一种计算机语言，尤用于创建网站)

```
// Java program to implement
// the above approach
import java.util.*;

public class GFG {

    // Function to select the array elements to
    // maximize the sum of the selected elements
    public static int maximumSum(int[] a, int count,
                                 int index, int n,
                                 int[][] dp)
    {
        // If the entire array
        // is solved
        if (index == n)
            return 0;

        // Memoized subproblem
        if (dp[index][count] != -1)
            return dp[index][count];

        // Calculate sum considering the
        // current element in the subsequence
        int take_element
            = a[index] * count
              + maximumSum(a, count + 1,
                           index + 1, n, dp);

        // Calculate sum without considering the
        // current element in the subsequence
        int dont_take
            = maximumSum(a, count, index + 1, n, dp);

        // Update the maximum of the above sums
        // in the dp[][] table
        return dp[index][count]
            = Math.max(take_element, dont_take);
    }

    // Driver Code
    public static void main(String args[])
    {
        int n = 5;
        int a[] = { -1, -9, 0, 5, -7 };

        // Initialize the dp array
        int dp[][] = new int[n + 1][n + 1];
        for (int i[] : dp)
            Arrays.fill(i, -1);

        System.out.println(maximumSum(a, 1, 0, n, dp));
    }
}
```

## 蟒蛇 3

```
# Python3 program to implement
# the above approach

# Function to select the array elements to
# maximize the sum of the selected elements
def maximumSum(a, count, index, n, dp):

    # If the entire array
    # is solved
    if(index == n):
        return 0

    # Memoized subproblem
    if(dp[index][count] != -1):
        return dp[index][count]

    # Calculate sum considering the
    # current element in the subsequence
    take_element = (a[index] * count + 
                 maximumSum(a, count + 1,
                               index + 1, 
                               n, dp))

    # Calculate sum without considering the
    # current element in the subsequence
    dont_take = maximumSum(a, count, 
                           index + 1, n, dp)

    # Update the maximum of the above sums
    # in the dp[][] table
    dp[index][count] = max(take_element,
                           dont_take)

    return dp[index][count]

# Driver Code
n = 5
a = [ -1, -9, 0, 5, -7 ]

# Initialize the dp array
dp = [[-1 for x in range(n + 1)]
          for y in range(n + 1)]

# Function call
print(maximumSum(a, 1, 0, n, dp))

# This code is contributed by Shivam Singh
```

## C#

```
// C# program to implement
// the above approach
using System;

class GFG{

// Function to select the array elements to
// maximize the sum of the selected elements
public static int maximumSum(int[] a, int count,
                             int index, int n,
                             int[,] dp)
{

    // If the entire array
    // is solved
    if (index == n)
        return 0;

    // Memoized subproblem
    if (dp[index, count] != -1)
        return dp[index, count];

    // Calculate sum considering the
    // current element in the subsequence
    int take_element = a[index] * count + 
                       maximumSum(a, count + 1,
                                     index + 1,
                                     n, dp);

    // Calculate sum without considering the
    // current element in the subsequence
    int dont_take = maximumSum(a, count, 
                               index + 1, n, dp);

    // Update the maximum of the above sums
    // in the [,]dp table
    return dp[index, count] = Math.Max(take_element, 
                                       dont_take);
}

// Driver Code
public static void Main(String []args)
{
    int n = 5;
    int []a = { -1, -9, 0, 5, -7 };

    // Initialize the dp array
    int [,]dp = new int[n + 1, n + 1];
    for(int i = 0; i < n + 1; i++)
    {
        for(int j = 0; j < n + 1; j++)
        {
            dp[i, j] = -1;
        }
    }
    Console.WriteLine(maximumSum(a, 1, 0, n, dp));
}
}

// This code is contributed by PrinciRaj1992
```

## java 描述语言

```
<script>

// JavaScript program to implement
// the above approach
var N = 6;

// Function to select the array elements to
// maximize the sum of the selected elements
function maximumSum(a, count, index, n, dp)
{
    // If the entire array
    // is solved
    if (index == n)
        return 0;

    // Memoized subproblem
    if (dp[index][count] != -1)
        return dp[index][count];

    // Calculate sum considering the
    // current element in the subsequence
    var take_element = a[index] * count + 
                         maximumSum(a, count + 1, 
                                  index + 1, n, dp);

    // Calculate sum without considering the
    // current element in the subsequence
    var dont_take = maximumSum(a, count, 
                               index + 1, n, dp);

    // Update the maximum of the above sums
    // in the dp[][] table
    return dp[index][count] = Math.max(take_element, 
                                  dont_take);
}

// Driver Code
var n = 5;
var a = [ -1, -9, 0, 5, -7];
// Initialize the dp array
var dp = Array.from(Array(N), ()=>Array(N).fill(-1));
document.write(maximumSum(a, 1, 0, n, dp));

</script>
```

**Output:** 

```
14
```

***时间复杂度:**O(N<sup>2</sup>)*
***辅助空间:** O(N <sup>2</sup> )*