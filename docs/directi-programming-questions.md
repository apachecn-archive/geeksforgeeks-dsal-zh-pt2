# 定向面试|第七集(编程题)

> 原文:[https://www . geesforgeks . org/directi-programming-questions/](https://www.geeksforgeeks.org/directi-programming-questions/)

一篇文章包含了我最近在校园和朋友的大学里遇到的 Directi 编程问题。

**1)** 给你一个字符串 S，S 的每个字符不是‘a’，就是‘b’。您希望反转 S 的一个子字符串，这样新字符串在字典上就比您通过反转一个子字符串得到的所有其他字符串都小。
例如，给定“ab”，您可以选择反转从索引 2(从 0 开始)开始的子字符串“ab”。这就给了你“阿爸”这个字符串。但是，如果您选择从索引 1 开始反转子字符串“ba”，您将得到“aabb”。没有办法获得更小的字符串，因此反转[1，2]范围内的子字符串是最佳选择。

**输入**
第一行包含一个数字 T，测试用例的数量。
每个测试用例包含一个字符串 s，该字符串的字符将来自集合{ a，b }。

**输出**
对于每个测试用例，打印两个用逗号分隔的数字；例如“x，y”(没有引号，也没有任何额外的空格)。“x，y”分别描述子串的起始索引(从 0 开始)和结束索引，为了获得最小的字典式字符串，必须反转子串。如果有多个可能的答案，请打印带有最小“x”的答案。如果仍有多个答案，请打印带有最小“y”的答案。
**约束条件**
1<= T<= 100
1<= S 的长度< = 1000
**样本输入**T11】5
abab
ABBA
bbaa
AAAA
babaabba
T18】样本输出 T20】1，2
1，3
0

**2)** 给定两个字符串 I 和 F，其中 I 为初始状态，F 为最终状态。每个状态将包含“a”、“b”和一个由“_”表示的空槽。您的任务是以最少的操作次数从初始状态进入最终状态。
允许操作为
1。您可以用任何相邻字符交换空字符。(例如‘ABA _ ab’可以转换为‘ab _ aab’或‘abaa _ b’)。
2。只有当相邻字符不同于相邻字符旁边的字符时，才能将空字符与相邻字符旁边的字符交换。(例如‘ABA _ ab’可以转换成‘a _ abab’或‘abab _’，但‘ab _ aab’不能转换成‘abaa _ b’，因为‘a’不能跳过‘a’)。
**输入**
第一行包含单个整数 T–测试用例数(小于 25)。接下来是 t 测试用例。
每个测试用例包含两个不同行的字符串 I 和 F，其中 I 是初始状态，F 是最终状态。I 和 F 可能相等。它们的长度总是相等的。它们的长度至少是 2。它们的长度永远不会超过 20。

**输出**
对于每个测试用例，输出一行包含从初始状态到达最终状态所需的最小步数。你可以假设它总是有可能从初始状态到达最终状态。你可以假设没有一个答案超过 30。
**示例**
**输入:**
2
a _ b
ab _
ABA _ a
_ baaa

**输出:**
1
2

**3)** 从下面的伪码中为二叉查找树生成概率预序遍历

```
function preorder(u) {
    if u is null then return
    print u.label
    r = either 0 or 1 with 50% probability
    if r == 0
        preorder(u.left_child)
        preorder(u.right_child)
    if r == 1
        preorder(u.right_child)
        preorder(u.left_child)
}
```

给定二叉查找树的预定行程，你总是可以独特地建造二叉查找树。因为，二叉查找树的有序遍历当然是标签的排序列表。
给定某个二叉查找树的一个概率前序遍历，打印上述算法可能生成的不同概率前序遍历的数量。为清楚起见，请参见解释部分。

**输入**
输入的第一行等于 N，测试用例的数量。然后是 N 个测试用例的描述。每个测试用例中的第一行是整数 N，即二叉查找树中的节点数。在下一行，有 N 个整数——一个概率性的二叉查找树前序遍历。测试用例中所有节点的标签都是不同的。测试用例中每个标签的值在 1 到 N 之间，包括 1 和 N。您可以假设输入将是某个二叉查找树的有效概率前序遍历。

**输出**

对于每个测试用例，单独在一行上打印一个数字。这个数字应该是二分搜索法球座存在的不同概率的预序穿越数——包括测试用例中给出的一个。你可以假设答案总是小于或等于 1，000，000，000。事实上，很容易看出，答案永远不会超过 2^30。
**约束**T3】1<T<= 10000
1<= N<= 30

**样本输入**
3
3
2 1 3
3
1 2 3
5
2 4 3 5 1

**样本输出**
2
1
4

**4)** 给你一个 1000 万位的大数组。每个位最初都是 0。您可以执行“翻转起始索引和结束索引之间的所有位，包括起始索引和结束索引”类型的操作。给定一系列这样的操作，对数组执行所有操作。最后，将数组拆分成 4 位的集合——前 4 位、后 4 位、后 4 位，依此类推。每个集合可以代表一个十六进制整数。正好有 2，500，000 个十六进制整数。计算 2，500，000 个整数中从“0”到“f”的每个十六进制整数的频率，并打印出来。为清楚起见，请参见输入/输出和样本输入/输出的解释。
**输入**
第一行输入包含一个整数 T (1？t？10)、测试用例的数量。然后是测试用例的描述。您应该假设数组正好有 10，000，000 位，并且这些位在每个测试用例开始时都是未设置的。每个测试用例的第一行包含一个整数 N (1？n？10，000)，执行的操作数。接下来的 N 行包含由空格分隔的两个整数，分别是操作的开始索引和结束索引。请注意，翻转操作是从 start_index 到 end_index(含)执行的。此外，数组是 1 索引的，也就是说，最小的索引是 1，最大的索引是 10，000，000。
**输出**
对于每个测试用例，在一行输出 16 个整数，用单个空格字符分隔。第一个整数应该表示根据问题语句创建的 2，500，000 个十六进制整数中 0 出现的次数。第二个整数应该表示根据问题语句创建的 2，500，000 个十六进制整数中 1 出现的次数，依此类推。
**约束条件**
1<= start _ index<= end _ index
start _ index<= end _ index<= 10，000，000
**样本输入**
2
2
1 4
999999997 1000000
2
3 6
5 8

**样本输出**
2499998 0 0 0 0 0 0 0 0 0 2
2499998 0 2 0 0 0 0 0 0 0 0 0

**5)** 给你两个长度相同的字符串，比如 A 和 B，比如 N，你可以用 A[i]和 B[i]交换 1 和 N 之间的所有 I，包括 1 和 N。您不能在 A 或 B 中交换两个字符。此外，您只能交换 A 中的一个字符与 B 中同一索引处的字符，而不能交换其他字符。您可以零次或多次执行此操作。
您希望通过操作修改字符串，以使字符串中唯一字符的数量很少。实际上，如果 n(A)是 A 中的唯一字符数，n(B)是 B 中的唯一字符数；您希望执行的操作使 max(n(A)，n(B))尽可能小。
打印所有操作后的 max(n(A)，n(B))值。

**输入**
第一行输入包含 T，测试用例的数量。然后是测试用例的描述。每个测试用例在第一行包含数字 N。测试用例的接下来两行包含两个 N 字母字符串，分别是 A 和 B。这些字母是小写英文字母。
**输出**
为每个测试用例打印一行。执行所有操作后，打印 max(n(A)，n(B))的值，使该值尽可能小。
**约束条件**
1<= T<= 100
1<=长度(A) < = 16
长度(B) =长度(A)

**样品输入**
【3】
【7】
【直接】
【itcerid】

【Ababa】
【babb】
【abaa】
【abab】

**样本输出**
4
1
2

**6)** 让我们定义一个字符串作为开始标记，其中 x 是拉丁字母表中的任何一个小字母。
每个开始标记与该类型的结束标记匹配，其中 x 是相同的字母。
标签可以相互嵌套，即一个开始和结束标签对可以位于另一个标签对内部。

让我们定义一个 XML 文本的概念:

1)空字符串是 XML-text
2)如果 S 是 XML-text，那么“  ”(引号和空格是为了清楚起见)也是 XML-text，
其中 a 是任何小的拉丁字母
3)如果 S1、S2 是 XML-text，那么“S1 S2”(引号和空格是为了清楚起见)也是 XML-text

给你一个字符串。您必须验证给定的字符串是否是有效的 xml。
**输入**
第一行包含测试用例的数量
对于每个测试用例:
只有一行包含 xml 标记的字符串 s。
**输出**
如果 s 是有效的 xml，则在一行中打印一个字符串 TRUE，否则为 FALSE。
**约束条件**
0<t<= 10
0<长度 S < = 10^5
**例**
**输入:**
2

****输出:**
真
假**

****7)** 在这个问题中，我们考虑两个楼梯，A 和 B，它们彼此平行。楼梯 A 和 B 都有 N 级，其中 A[i]，B[i]分别代表 A 和 B 的第 I 级。
每一步都有一定的惩罚，如果你使用那一步，你将会受到相同的惩罚。走了几步之后，你会累积你所走过的每一步的惩罚。
你的最大跳跃长度为 K，即从 A[i]开始，你可以向前跳跃到 A[i+1]或 A[I+2]……或 A[i+K]，中间不使用任何步骤。
换楼梯还可以跳楼梯，额外罚 P。例如，从 A[i]你可以跳到 B[i+1]或 B[i+2] …或 B[i+K]，并附加一个惩罚 P 以及你所访问的步骤的惩罚。你也可以从楼梯乙跳到楼梯甲，这也会招致额外的惩罚，以及你所走的那一步的惩罚。
观察每一步只能向前跳。你的最终惩罚将是你参观的所有台阶的惩罚加上你穿过楼梯次数的 P 倍。
可以从 A[1]或者 B[1]开始，应该到达 A[N]或者 B[N]最小化途中累积的惩罚。找到你将积累的最小惩罚。
**输入**
输入中的第一行等于 T，测试用例的数量。然后是测试用例的描述。每个测试用例的第一行有三个整数 N，两个楼梯的步数 K，最大跳跃长度 P，过楼梯的惩罚。在每个测试用例的第二行，有 N 个整数，其中 I 个整数代表步骤 A[i]的惩罚。在每个测试的第三行，有 N 个整数，其中 I 个整数代表步骤 B[i]的惩罚。
**输出**
对于每个测试用例，输出一行包含您可以在从{ A[1]或 B[1]开始到{ A[N]或 B[N]结束的路径上累积的最小惩罚。
约束
1 < = T < = 10**

**1 <= N <= 1000**

**0 <= P <= 1000**

**1 <= K <= N**

**0 <= A[i], B[i] <= 1000
**示例**
**输入:**
6
4 1 0
1 2 3 4
1 2 3 4
4 1 0
1 2 3 4
4 3 2 1
4 2 0
1 2 3 4
4 3 2 1
4 1 10
1 2 3 4
4 3 2 1
4 2 10** 

****输出:**
10
6
4
10
7
100**

****8)** 在这个问题中，我们考虑根为 r 的有根树 Tr(不一定是二叉树)。dfs 深度优先搜索-从根 r 开始遍历树 t r，以特定的顺序访问 Tr 的节点。让我们称这个订单为 dfs 订单。
观察在 dfs 遍历期间，从每个节点，我们可以选择首先遍历哪个子节点。
这些不同的选择导致不同的 dfs 排序。您必须找到 dfs 访问节点的不同方式，即从根 r 开始，一个 dfs 在 Tr 上可能的不同节点顺序的数量。**

**考虑一个例子 Tr，其中 3 个节点标记为 1、2、3，1 是根，2 和 3 是 1 的子节点。**

**该 Tr 上的 dfs 可以按顺序(1，2，3)或(1，3，2)访问节点。因此有两种 dfs 排序方式。**

**更多示例参见示例测试用例
**输入**
输入中的第一行等于 T，测试用例的数量。然后是测试用例的描述。每个测试用例中的第一行是整数 N，即树 Tr 中的节点数。每个节点都用 1 到 N(含 1 和 N)之间的不同整数标记。在下一行，有 N 个整数，其中 I 个整数表示根树 Tr 中标记为 I 的节点的父标签。测试用例中每个标签的值在 1 到 N 之间，包括 1 和 N。标签为 I 的节点的父节点的标签小于 I。标签为 1 的节点是根节点 r。在测试用例中，根节点的父节点将被指定为 0。
**输出**
对于每个测试用例，输出一行包含 Tree Tr 上 dfs 可能的不同顺序的数量。因为这个数字可能很大，所以输出模 1，000，000，007 的值。**

****约束**T2】1<= T<= 100
1<= N<= 1000
0<= A【I】<I**

****例****

****输入**:
6
2
0 1
3
0 1 1
4
0 1 1
3
0 1 2
4
0 1 2
5
0 1 2 2 2**

****输出**:
1
2
6
1
2
4**

****9)** 卡特里娜是个超级极客。她喜欢优化事物。假设她位于包含“m”行和“n”列的二维网格的位置(0，0)。她想到达这个网格的右下方，通过尽可能少的细胞。
网格中的每个单元格都包含一个正整数，正整数定义了 Katrina 到达该单元格时可以向右或向下跳转的单元格数。她不能向左或向上移动。
你需要找到 Katrina 的最优路径，这样从网格左上角位置开始，她就能以最小的跳跃次数到达右下角位置。
**输入**
给你提供了一个模板，你必须在其中实现一个功能 minHops。minHops 的声明看起来像**

**C / C++
int minHops(int 矩阵[64][64]，int m，int n)**

**Java
status int minHops(int[][]矩阵，int m，int n)**

****输出**
该函数应返回从网格左上角到右下角应触摸的最小单元格数(包括触摸左上角和右下角的单元格)。如果不存在路径，则返回 0。
**示例**
假设网格是这样的**

**2 4 2
5 3 8
1 1 1**

**从 A(0，0)开始包含“2”，因此您可以转到(0，2)或(2，0)。
因此存在以下两条路径从(0，0)
(0，0) = > (0，2) = > (2，2)
(0，0) = > (2，0) = > (2，1) = > (2，2)**

**因此，这个测试用例的输出应该是 3**

**例 2**

**5 3 8 2
6 4 2 1**

**没有从(0，0)到(1，3)的路径，因此这种情况下的输出应该是 0**

**例 3**

**2 3 2 1 4
3 2 5 8 2
1 2 2 1**

**这种情况下的各种路径为
(0，0) = > (0，2) = > (2，2) = > (2，4)
(0，0) = > (2，0) = > (2，1) = > (2，2) = > (2，4)**

**所以输出，在这种情况下，应该是 4**

****10)** 考虑一下拥有网格状房屋结构的纽约市。城市地图以矩阵的形式提供给你。每个单元代表一栋建筑。从每栋楼出发，可以往东、西、北、南四个方向去相邻的四栋楼。蜘蛛侠想营救某栋建筑上的受害者。你将被告知受害者的位置，蜘蛛侠位于(1，1)号楼。但是，有一个条件是，如果建筑之间的高度差大于某个特定值，蜘蛛侠就不能在建筑之间跳跃。找到蜘蛛人穿过最少的建筑到达受害者的方法。**

**输入
输入包含多个测试用例。第一行是一个整数 T，表示要遵循的测试用例的数量。**

**每个测试用例的第一行有 4 个数字——M、N、X、Y、d。这里 MxN 是城市网格的维度。(X，Y)是受害者的位置。**

**接下来是 M 线。每一行由 N 个与建筑高度相对应的用空格分隔的正整数组成。d 是蜘蛛侠能穿越的建筑高度的最大差异。
输出
每个测试用例一行包含一个整数，表示蜘蛛侠需要穿越的最小建筑数量。如果不可能，返回-1。
约束
应该包含输入数据的所有约束。格式为:
1 < = T、M、N、X、Y<= 100
1<= D<= 100000
每栋高度将小于 100000**

**示例
输入:
3
3 3 3 2
1 2 3
6 9 4
7 8 5
3 3 3 3 1
1 8 3
9 5 6
7 2 4
3 3 3 1
1 6 7
2 5 8
3 4 9**

**输出:
3
-1
7**

****11)** 给你一棵 N 节点的树。每个节点将从 0 到 N-1 编号，并且每个节点 I 与值 vi 相关联。
假设树的根在节点 0。
如果 x 出现在从节点 0 到节点 y 的路径中，则节点 y 被称为节点 x 的后代。以节点 x 为根的子树被定义为是 x(包括 x)的后代的所有节点的集合。
如果一个子树中所有节点的值都相等，则该子树称为单值树。
给定树和与树中节点相关联的值，您需要找到树中单值子树的数量。
**输入**
第一行包含一个整数 N，即树中的节点数。接下来的 N 行包含表示与每个节点相关联的值的 N 个整数，即第一行包含与节点 i-1 相关联的值。接下来的 N-1 行给出了树中边的信息。每行包含两个用空格分隔的整数 x 和 y，表示节点 x 和节点 y 之间的边。
**输出**
您必须打印给定树中包含的单值子树的数量。
约束
N < =30000
**示例**
**输入:**
5
0
0
1
1
1
0 1
0 2
2 3
2 4
输出:
4**

****12)** Directi 每隔一段时间组织一次 FNCS(周五晚上的寒战会议)(非常好玩！).Directians 来享受各种活动，累了就出去，精神焕发了再回来。为方便起见，任何人的进出都被记录下来。一天结束时，组织者想知道活动期间的最大人数是多少。所以他请求你的帮助。他这样给你每个人的进出时间:**

```
Person   Entry_time Exit_time
#1       6          10
#2       1          7
#3       1          4  
#4       8          10
#5       6          10
```

**人的身份不重要。#1 和#4 可能是同一个人。在这种情况下，活动期间任何时候出席的人数最多为 3 人。
你的任务是阅读参赛作品，并计算活动期间到场的最大人数。
**输入**
该输入包含多个测试用例。第一行是一个整数 T，表示要遵循的测试用例的数量。每个测试用例的第一行是一个数字 N，入口-出口记录的数量。接下来是 N 行。每行由两个用空格分隔的整数组成，分别对应一个人的进入时间和离开时间。
**输出**
每个测试用例一行，包含单个整数，表示任何时候出席聚会的人数最多。
约束
1<= T<= 100
1<= N<= 100
1<= ENTRY _ TIME<EXIT _ TIME<= 10000000
保证人员的进出时间是有区别的**

****示例**
**输入**:
1
6
7 8
4 9
6 9
8 17
2 14
2 10**

****输出** :
5**

**如果你喜欢极客博客并想投稿，你也可以写一篇文章并把你的文章邮寄到 contribute@geeksforgeeks.org。看到你的文章出现在极客博客主页上，帮助其他极客。** 

**[All Practice Problems for Directi](https://practice.geeksforgeeks.org/company/Directi/) !**

## **相关实践问题**

**[Maximum Intervals Overlap](https://practice.geeksforgeeks.org/problems/maximum-intervals-overlap/0)**